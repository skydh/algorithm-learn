package com.dh.leetcode;

/**
 * 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
 * 
 * _9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # # 例如，上面的二叉树可以被序列化为字符串
 * "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。
 * 
 * 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。
 * 
 * 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。
 * 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。
 * 
 * 示例 1:
 * 
 * 输入: "9,3,4,#,#,1,#,#,2,#,6,#,#" 输出: true 示例 2:
 * 
 * 输入: "1,#" 输出: false 示例 3:
 * 
 * 输入: "9,#,#,1" 输出: false
 * 
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary
 * -tree
 * 
 * @author Lenovo
 *
 */
public class IsValidSerialization {
	/**
	 * 仅仅前序是无法构造一个树的。 我们发现规则如下:
	 * 
	 * # 节点全部为叶子节点，叶子节点必须为#号节点。 一个这样的二叉树（算上#符号）其叶子节点数目，等于非叶子节点数目+1;
	 * 
	 * 这个公式很有意思，我们这样算出来。
	 * 
	 * 2^0+2^1+2^2+...+2^n=K 所有节点
	 * 2*(2^0+2^1+2^2+...+2^n)=2^1+2^2+2^3+...+2^(n+1)=2K 2个公式相减
	 * 
	 * K=2^(n+1)-1
	 * 
	 * 最后一层节点 2^n
	 * 
	 * 我们得到公式 叶子节点=2^n=非叶子节点（2^n-1）+1
	 * 
	 * 继续推算，我们的这个树不是完全意义的全二叉树，可能少了一部分，假设少了一个2层的树。那么是叶子节点-2+1，非叶子节点-1，关系不变，推算，
	 * 减少一个层级为k的树，叶子节点
	 * 减2^k+1,非叶子节点-(2^k-1),我们发现减小的节点数目是一致的，因此这个树满足规律，叶子节点=非叶子节点+1
	 * 
	 * 
	 * 再次分析，前序遍历，那么就是本，左，右
	 * 
	 * 分析一下后，最后2个字符必然都是#。 先根据这个
	 * 
	 * 继续分析，前序遍历，本，左，右，仅仅本左，非叶子节点+1，叶子节点-1，非叶子节点优先遍历，那么遍历完这个本左，后，总值应该0.加上右，则是-1.
	 * 
	 * @param preorder
	 * @return
	 */
	public boolean isValidSerialization(String preorder) {
		if (preorder.equals("#"))
			return true;

		if (!preorder.endsWith("#,#") || preorder.startsWith("#"))
			return false;
		String[] args = preorder.split(",");
		int count = 1;
		for (int i = 0; i < args.length-1; i++) {
			if (count == 0)
				return false;
			if (args[i].equals("#"))
				count--;
			else
				count++;
		}

		return count == 1;

	}
}
